open! Alice_stdlib
open Alice_package
module Package_with_deps = Dependency_graph.Package_with_deps

type t =
  { package : Package.t
  ; transitive_dependency_closure_excluding_package : Package.Typed.lib_only_t list
  }

let of_package_with_deps package_with_deps =
  let package = Package_with_deps.package package_with_deps in
  let transitive_dependency_closure_excluding_package =
    Package_with_deps.transitive_dependency_closure_excluding_package package_with_deps
  in
  { package; transitive_dependency_closure_excluding_package }
;;

let source_code { package; transitive_dependency_closure_excluding_package } =
  let package_name = Package.name package in
  let package_name_s = Package_name.to_string package_name in
  let package_module_name = Module_name.of_package_name package_name in
  let internal_module_name = Module_name.internal_modules package_name in
  let public_module_name = Module_name.public_interface_to_open package_name in
  let deprecated_message =
    {|[@@deprecated "This module is an empty shadow of another module intended for internal use only."]|}
  in
  let shadow_transitive_closure_internal_modules =
    let lines =
      List.concat_map transitive_dependency_closure_excluding_package ~f:(fun package ->
        let shadow =
          sprintf
            "module %s = struct end"
            (Module_name.internal_modules (Package.Typed.name package)
             |> Module_name.to_string_uppercase_first_letter)
        in
        [ shadow; deprecated_message ])
    in
    let lines =
      match lines with
      | [] -> []
      | lines ->
        let comment =
          {|(* Shadow the internal modules of the transitive closure of this package. When
compiling modules from packages that depend on this package, the public
directories of all this package's transitive dependencies must be passed
with -I to allow this package to define aliases to modules defined among its
dependencies. However these directories contain files exposing internal
modules from their respective packages which are shadowed in their
corresponding public interfaces, and packages depending on this package
don't necessarily depend on each package in its transitive closure, so won't
open the modules necessary to shadow the internal modules of each package in
its transitive closure. Thus they must be shadowed again here. *)|}
        in
        comment :: lines
    in
    String.concat lines ~sep:"\n"
  in
  let shadow_transitive_closure_public_interfaces =
    let lines =
      List.concat_map transitive_dependency_closure_excluding_package ~f:(fun package ->
        let shadow =
          sprintf
            "module %s = struct end"
            (Module_name.public_interface_to_open (Package.Typed.name package)
             |> Module_name.to_string_uppercase_first_letter)
        in
        [ shadow; deprecated_message ])
    in
    let lines =
      match lines with
      | [] -> []
      | lines ->
        let comment =
          {|(* Shadow the public interfaces to the transitive closure of this package. As
described above, all the public directories of this package's transitive
dependency closure are passed with -I while compiling client code. This
would allow client code to access the public interface of any package from
this package's dependency closure. To prevent this, the public interfaces to
each package in this package's dependency closure is shadowed here. *)|}
        in
        comment :: lines
    in
    String.concat lines ~sep:"\n"
  in
  sprintf
    {|(* Public interface to package %S, generated by Alice. *)

(* This file's module is expected to be passed with -open when compiling each
   module of each package depending on this package. The public interface to
   this package is defined in a module named Lib, which is aliased to this
   package's name here, which will make the public interface to this module
   available to client code under a module named after this package. *)
module %s = %s.Lib

(* Shadow the internal modules of this package. When compiling modules from
   packages that depend on this package, the public directory of this package
   must be passed with -I to allow its internal modules to be aliased in its
   public interface. However doing so would leak all private modules to client
   code. To prevent this, the module containing all private modules of this
   package is shadowed here. *)
module %s = struct end
%s

(* Also shadow this package's public interface. This will prevent client code
   from accessing this package's contents by referring to the public interface
   directly. This isn't strictly needed for correctness but it lets us force
   client code to only access the package by its module aliased at the top of
   this file. *)
module %s = struct end
%s

%s

%s
|}
    package_name_s
    (Module_name.to_string_uppercase_first_letter package_module_name)
    (Module_name.to_string_uppercase_first_letter internal_module_name)
    (Module_name.to_string_uppercase_first_letter internal_module_name)
    deprecated_message
    (Module_name.to_string_uppercase_first_letter public_module_name)
    deprecated_message
    shadow_transitive_closure_internal_modules
    shadow_transitive_closure_public_interfaces
;;
